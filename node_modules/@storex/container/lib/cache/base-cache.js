"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
var SAVE_CACHE = true;
const CACHES = new Set();
class BaseCache extends events_1.EventEmitter {
    constructor(args) {
        super();
        this._onUpdateOnce = [];
        this._isUpdating = false;
        this._labelCounts = {};
        this._updatedDate = 0;
        this._changeDate = 0;
        this.init = () => {
            this._updatedDate = 0;
            this._changeDate = 0;
            this.initData();
            if (this._getOnInit) {
                setTimeout(() => {
                    this.needToUpdate();
                    this.get();
                });
            }
        };
        this._registerToRoots = roots => {
            const register = cache => {
                if (cache instanceof BaseCache) {
                    cache.on("need-to-update", this.needToUpdate);
                }
                else {
                    throw new TypeError("[Cache::_registerToRoots] The cacheRoot must be either array of Cache or object that all values are Cache");
                }
            };
            if (roots instanceof Array) {
                for (const cache of roots) {
                    register(cache);
                }
            }
            else if (typeof roots === "object") {
                for (const key in roots) {
                    register(roots[key]);
                }
            }
            else if (roots) {
                throw new TypeError("[Cache::_registerToRoots] The cacheRoot must be either array of Cache or object that all values are Cache");
            }
        };
        /**
         * update that some changes are detected and cache need to be updated.
         *
         * @memberof BaseCache
         */
        this.needToUpdate = (msg) => {
            if (SAVE_CACHE === true) {
                this._changeDate = Date.now();
                console.log(`[Cache::${this._name}] Data need to update`);
                this.emit("need-to-update", msg);
            }
            else {
                console.warn(`[Cache::${this._name}] Ths cache will not update because process.env.save_cache !== "true"`);
            }
        };
        if (!args.getData && (!args.rootCaches || !args.translateCache)) {
            throw new Error(`You must set either args.getData or 'args.rootCache' and 'args.translateCache'`);
        }
        this._is_failed = false;
        this._name = args.name;
        this._getData = args.getData;
        this._rootCaches = args.rootCaches;
        this._registerToRoots(this._rootCaches);
        this._translateCache = args.translateCache;
        this._delay = args.delay || 1000;
        this._lazy = !(args.lazy === false);
        this._lazy_delay = args.lazyDelay;
        CACHES.add(this);
        setTimeout(this.init.bind(this));
    }
    static init() {
        for (const cache of CACHES) {
            cache.init();
        }
    }
    /**
     * get the cache
     *
     * @param {boolean} [asObject]
     * @returns
     * @memberof BaseCache
     */
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNeedToUpdate && !this._isUpdating) {
                try {
                    yield this._get_and_set();
                }
                catch (e) {
                    console.error(`[Cache::${this._name}] Failed to get new data`, e);
                    return Promise.reject(e);
                }
            }
            else if (this._isUpdating) {
                // if already updating.
                let a = null;
                return new Promise((resolve, reject) => {
                    this._onUpdateOnce.push((data, err) => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve(data);
                    });
                });
            }
            else if (this._is_failed) {
                try {
                    yield this._get_and_set();
                }
                catch (e) {
                    console.error(`[Cache::${this._name}] Failed to get new data`, e);
                    return Promise.reject(e);
                }
            }
            return this.data;
        });
    }
    get isNeedToUpdate() {
        let rootCache = false;
        if (!this._updatedDate || this.data === undefined) {
            return true;
        }
        // if (this._rootCache) {
        //   rootCache = this._rootCache.isNeedToUpdate;
        // }
        return this._changeDate > this._updatedDate || rootCache;
    }
    /**
     *
     *
     * @param {boolean} [asObject]
     * @returns
     * @memberof BaseCache
     */
    getCopy() {
        return __awaiter(this, void 0, void 0, function* () {
            return clone(yield this.get());
        });
    }
    /**
     * remove the cache
     *
     * @memberof BaseCache
     */
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            // this._cacheDir = undefined; // todo;
        });
    }
    destructor() {
        CACHES.delete(this);
    }
    /**
     * update the cache
     *
     * @private
     * @returns
     * @memberof BaseCache
     */
    _get_and_set() {
        return __awaiter(this, void 0, void 0, function* () {
            this._isUpdating = true;
            const preUpdateTime = this._updatedDate;
            this._updatedDate = Date.now();
            // if delay
            if (typeof this._delay === "number") {
                let interval = Date.now() - (this._changeDate || 0);
                if (interval < this._delay) {
                    yield sleep(this._delay - interval);
                }
            }
            this._updatedDate = Date.now();
            console.log(`[Cache::${this._name}] Fetching data`);
            let data;
            if (typeof this._getData === "function") {
                try {
                    data = yield this._getData();
                }
                catch (e) {
                    return onCatch.apply(this, [e]);
                }
            }
            if (typeof this._translateCache == "function") {
                try {
                    data = yield this._translateCache({
                        action: "set",
                        newData: data,
                        oldData: this.data,
                        roots: this._rootCaches
                    });
                }
                catch (e) {
                    return onCatch.apply(this, [e]);
                }
            }
            try {
                yield this.set(data);
            }
            catch (e) {
                return onCatch.apply(this, [e]);
            }
            this._is_failed = false;
            this._isUpdating = false;
            this._onUpdateOnce.forEach(f => {
                f(this.data);
            });
            this._onUpdateOnce = [];
            this.emit("change");
            function onCatch(e) {
                console.error(`[Cache::${this._name}] Failed to get data`, e);
                this._updatedDate = preUpdateTime;
                this._isUpdating = false;
                this._is_failed = true;
                this._onUpdateOnce.forEach(f => {
                    f(undefined, e);
                });
                this._onUpdateOnce = [];
                this.emit("failed");
                return Promise.reject(e);
            }
        });
    }
}
exports.BaseCache = BaseCache;
function clone(obj) {
    let copy;
    // Handle the 3 simple types, and null or undefined
    if (null === obj || "object" !== typeof obj) {
        return obj;
    }
    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }
    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (let i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }
    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (const attr in obj) {
            if (obj.hasOwnProperty(attr)) {
                copy[attr] = clone(obj[attr]);
            }
        }
        return copy;
    }
    throw new Error(`Unable to copy obj! Its type isn't supported.`);
}
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
