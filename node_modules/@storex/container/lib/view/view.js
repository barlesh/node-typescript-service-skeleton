"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@storex/core");
/**
 *
 *
 * @export
 * @class View
 */
class View extends core_1.Dispatcher {
    constructor({ dispatchers, transform }) {
        super(); // todo
        this._is_need_to_update = true;
        this._unregisterFunc = [];
        this._is_updating = false;
        this.context = {};
        this._preAndPostUpdate = (options) => (eventsData, events) => {
            if (this._is_updating) {
                return; // todo
            }
            try {
                const { pre, post } = options.onDispatch;
                // let isUpdate
                let { data, context } = this;
                if (pre) {
                    this._is_updating = true;
                    pre(this._sources, { eventsData, events, data, context });
                    this._is_updating = false;
                }
                data = this.data;
                context = this.data;
                this.update();
                if (post) {
                    this._is_updating = true;
                    post(this._sources, { eventsData, events, data, context });
                    this._is_updating = false;
                }
            }
            catch (err) {
                console.error(err);
                this._is_updating = false;
            }
        };
        this.update = () => {
            if (this._is_updating) {
                return; // todo
            }
            this._is_updating = true;
            try {
                const result = this._transform(this._sources, {
                    oldData: this.data,
                    context: this.context
                });
                if (!(result instanceof Promise)) {
                    this.data = result;
                }
                else {
                    result.then(r => (this.data = r), err => console.error("Failed to update the View", err));
                }
            }
            catch (err) {
                console.error("Failed to update the View", err);
            }
            this._is_updating = false;
        };
        let _sources, _registerProps = [], _specificRegisterProps = [];
        if (dispatchers instanceof Array) {
            _sources = [];
            for (const i in dispatchers) {
                const val = dispatchers[i];
                if (val && val.dispatcher instanceof Object) { // Dispatcher
                    _sources.push(val.dispatcher);
                    if (val.onDispatch) {
                        _specificRegisterProps.push(val);
                    }
                    else {
                        _registerProps.push(val);
                    }
                }
                else if (val && val.dispatch && val.register) { // Dispatcher
                    _sources.push(val);
                    _registerProps.push(val);
                }
                else {
                    throw new TypeError("You must ot send dispatcher in resources arg");
                }
            }
        }
        else if (dispatchers instanceof Object) {
            _sources = {};
            for (let key in dispatchers) {
                const val = dispatchers[key];
                if (val && val.dispatch && val.register) { // Dispatcher
                    _sources[key] = val;
                    _registerProps.push(val);
                }
                else if (val && val.dispatcher instanceof Object) { // Dispatcher
                    _sources[key] = val.dispatcher;
                    if (val.onDispatch) {
                        _specificRegisterProps.push(val);
                    }
                    else {
                        _registerProps.push(val);
                    }
                }
                else {
                    throw Error("You must ot send dispatcher in resources arg");
                }
            }
        }
        core_1.Dispatcher.register(this.update, _registerProps);
        this._unregisterFunc.push(() => core_1.Dispatcher.unregister(this.update, _registerProps));
        if (_specificRegisterProps.length > 0) {
            for (let o of _specificRegisterProps) {
                const func = this._preAndPostUpdate(o);
                o.dispatcher.register(func, o.on);
                this._unregisterFunc.push(() => o.dispatcher.unregisterFromAll(func));
            }
        }
        this._sources = _sources;
        this._transform = transform;
    }
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    destroy() {
        this._unregisterFunc.forEach(func => func());
    }
}
__decorate([
    core_1.dispatch()
], View.prototype, "data", null);
exports.View = View;
function createView(args) {
    return new View(args);
}
exports.createView = createView;
