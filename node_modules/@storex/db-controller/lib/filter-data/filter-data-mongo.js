"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const filter_data_1 = require("./filter-data");
class FilterDataMongo extends filter_data_1.FilterData {
    constructor(filterData, validateFunc) {
        super(filterData, validateFunc);
        this.filter = (f) => {
            this.where = this.where.filter(f);
            return this;
        };
        this.map = (m) => {
            this.where = this.where.map(m);
            return this;
        };
        this.insertPath = () => {
            for (const w of this.where) {
                if (w.path) {
                    w.key = `${w.path}.${w.key}`;
                }
            }
            return this;
        };
    }
    get mongoFilter() {
        if (!this.where || this.where.length === 0) {
            return {};
        }
        const filter = {};
        for (const w of this.where) {
            const filterKeyVal = getFilterValue(w);
            if (filterKeyVal.val !== "" && filterKeyVal.val !== undefined) {
                filter[filterKeyVal.key] = filterKeyVal.val;
            }
        }
        return filter;
    }
    get mongoSortBy() {
        if (!this.sort || this.sort.length === 0) {
            return;
        }
        const sortObj = {};
        this.sort.forEach(item => {
            sortObj[item.key] = item.reverse ? 1 : -1;
        });
        return sortObj;
    }
    fixFilterWhereValue(dic) {
        this.fixFilterWhere(dic, "value");
    }
    fixFilterWhereKey(dic) {
        this.fixFilterWhere(dic, "key");
        for (const s of this.sort) {
            if (dic[s.key]) {
                s.key = dic[s.key];
            }
        }
    }
    fixFilterWhereType(dic) {
        this.fixFilterWhere(dic, "type");
    }
    fixFilterWhere(dic, key) {
        for (const w of this.where) {
            const val = dic[w.key];
            if (val === undefined) {
                continue;
            }
            if (typeof val === "function") {
                w[key] = val(w);
                continue;
            }
            if (typeof val === "string") {
                w[key] = val;
                continue;
            }
        }
    }
}
exports.FilterDataMongo = FilterDataMongo;
function getFilterValue(where) {
    let { type = "string", value, operator } = where;
    let key = where.key;
    let val;
    switch (type) {
        case "bool":
        case "boolean":
            val = operator === "!" ? { $ne: Number(value) } : { $eq: Number(value) };
            break;
        case "number":
            if (operator === "!") {
                val = { $ne: value };
            }
            else if (operator === ">") {
                val = { $gt: value };
            }
            else if (operator === "<") {
                val = { $lt: value };
            }
            else {
                val = value;
            }
            break;
        case "multi-range":
            if (operator === "!") {
                if (typeof value === "object") {
                    val = {
                        $not: {
                            $elemMatch: { min: { $lte: value.max }, max: { $gte: value.min } }
                        }
                    };
                }
                else {
                    val = {
                        $not: { $elemMatch: { min: { $lte: value }, max: { $gte: value } } }
                    };
                }
            }
            else if (operator === ">") {
                if (typeof value === "object") {
                    value = value.max;
                }
                val = { $gt: value };
                key = key + ".max";
            }
            else if (operator === "<") {
                if (typeof value === "object") {
                    value = value.min;
                }
                val = { $lt: value };
                key = key + ".min";
            }
            else {
                if (typeof value === "object") {
                    val = {
                        $elemMatch: { min: { $lte: value.max }, max: { $gte: value.min } }
                    };
                }
                else {
                    val = { $elemMatch: { min: { $lte: value }, max: { $gte: value } } };
                }
            }
            break;
        case "array":
        case "enum":
            if (value && value instanceof Array && value.length > 0) {
                val = { $in: value };
                if (operator === "!") {
                    val = { $not: val };
                }
            }
            break;
        case "string":
        default:
            val =
                operator === "!~"
                    ? { $not: new RegExp(value, "i") }
                    : new RegExp(value, "i");
    }
    return { key: key, val: val };
}
