"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// todo this class is abstract for mongo
class MongoCollectionWrapper {
    constructor({ getCollection, itemToId }) {
        this.getCollection = getCollection;
        this.itemToId = itemToId || (i => i._id);
    }
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const collection = yield this.getCollection();
            return yield collection.findOne({ _id: id });
        });
    }
    getManyByFilter(filter, whatGet) {
        return __awaiter(this, void 0, void 0, function* () {
            let collection = yield this.getCollection();
            let isLimit;
            filter.insertPath();
            const ftr = this.prepareFilter(filter);
            let c = yield collection.find(ftr.query, whatGet);
            const length = yield c.count();
            if (ftr.sortBy) {
                c = c.sort(ftr.sortBy);
            }
            if (ftr.limitData) {
                isLimit = true;
                c = c.skip(ftr.limitData.from).limit(ftr.limitData.limit);
            }
            const data = yield c.toArray();
            return isLimit
                ? {
                    data,
                    length
                }
                : data;
        });
    }
    set(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCollection()).updateOne({ _id: this.itemToId(data) }, { $set: data });
        });
    }
    update(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCollection()).updateOne({ _id: this.itemToId(data) }, data);
        });
    }
    add(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCollection()).insert(data);
        });
    }
    remove(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCollection()).deleteOne({ _id: id });
        });
    }
    removeMany(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCollection()).deleteMany({ _id: { $in: ids } });
        });
    }
    getMany(ids, whatGet) {
        return __awaiter(this, void 0, void 0, function* () {
            let collection = yield this.getCollection();
            let query = {};
            if (ids) {
                query._id = { $in: ids };
            }
            let c = yield collection.find(query, whatGet);
            return c.toArray();
        });
    }
    addMany(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCollection()).insertMany(data);
        });
    }
    prepareFilter(filter) {
        const query = filter ? filter.mongoFilter : {};
        if (query.id) {
            query._id = query.id;
            delete query.id;
        }
        const sortBy = filter ? filter.mongoSortBy : undefined;
        const limitData = filter ? filter.limitData : undefined;
        return {
            query,
            sortBy,
            limitData
        };
    }
}
exports.MongoCollectionWrapper = MongoCollectionWrapper;
